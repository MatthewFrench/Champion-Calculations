# Improvement Tracker

## Done
- Completed shared-rune-runtime parity and output hardening pass:
  - moved Arcane Comet, Summon Aery, Triumph, Gathering Storm, and Second Wind combat behavior fully into shared loadout runtime paths used by both controlled champion and enemies
  - added Hail of Blades and Dark Harvest runtime behavior in shared loadout runtime
  - moved rune runtime tuning ownership to `Simulation/data/simulator_defaults.json` (`rune_runtime_defaults`) with typed loading in `src/defaults.rs`
  - fixed-loadout rune sweep now evaluates keystones in parallel and supports repeat aggregation via `--fixed-sweep-seed-repeats`, with deterministic per-repeat combat seed variation
  - report generation now hard-enforces complete controlled champion rune/shard labels (no fallback “none selected” section)
  - rune proc telemetry now includes source-attribution breakdowns plus proc attempt/eligible counts, proc rates, and damage/healing share metrics in markdown and JSON outputs
  - rune proc telemetry runtime bookkeeping was refactored to fixed-index counters (array-backed) to remove hot-path hashmap allocation/lookup overhead
  - search-time simulations now disable full rune-proc telemetry collection by default; trace/report replay simulations explicitly enable it
  - added JSON contract coverage for run report, fixed-loadout report, fixed-loadout rune sweep report, and trace outputs (schema version + rune telemetry field shape)
  - added additional pool geometry regressions for moving targets, diagonal boundary checks, and non-zero effect-hitbox-radius range behavior
- Hardened controlled champion runtime/engine boundaries:
  - removed thin `ControlledChampionLoadoutRuntime` holder from engine state; retained stateless defensive policy APIs in `src/scripts/runtime/controlled_champion_loadout.rs`
  - added optional scenario `simulation.combat_seed` for deterministic combat-variation runs (enemy init ordering + initial auto-attack jitter)
- Added regression coverage for realism and calibration:
  - added rune formula breakpoint tests for Electrocute, Arcane Comet, First Strike cooldown/window behavior, and Aftershock resist-cap behavior
  - added engine regression test ensuring pool ticks hit all in-range enemies with expected tick count and mitigated total damage
- Expanded modeled combat-time rune coverage and telemetry:
  - added Electrocute, First Strike, and Phase Rush runtime behaviors
  - Aftershock now applies active-window resist mitigation in incoming-damage resolution
  - reports and trace JSON outputs now include rune proc telemetry totals (proc count, bonus damage, bonus healing)
- Added fixed-loadout keystone sweep mode:
  - `controlled_champion_fixed_loadout_rune_sweep` compares one fixed item build across all legal keystones in the baseline primary rune path
  - outputs include ranked markdown + structured JSON sweep summaries
- Added profile-aware unmodeled-rune quality gate policy:
  - `maximum_quality` now hard-rejects candidates with unmodeled runes
  - `fast`/`balanced` retain per-rune penalty mode
- Added CI guardrails for modeled rune behavior coverage:
  - runtime tests now assert observable effects for all modeled dynamic rune keys
  - dynamic-rune key list and modeled coverage expectations are kept in lockstep by test
- Added generic combat-time rune trigger runtime layer and modeled additional keystones:
  - runtime now has explicit trigger hooks for on-hit, ability-hit, outgoing-damage healing, and immobilize-triggered effects
  - modeled keystones now include Press the Attack, Fleet Footwork, Conqueror, and Aftershock
  - controlled champion and enemy script paths now call the same shared runtime hooks where applicable
- Added explicit unmodeled-rune quality gating for search scoring:
  - new search defaults/config:
    - `unmodeled_rune_hard_gate`
    - `unmodeled_rune_penalty_per_rune`
  - candidate scoring now either rejects or penalizes loadouts that include unmodeled runes, based on policy
  - diagnostics/report JSON now include gate configuration and rejected/penalized candidate counters
- Added keystone regression coverage:
  - engine tests now validate combat deltas for Press the Attack, Fleet Footwork, Conqueror, and Aftershock trigger behavior
  - runtime unit tests validate stack/proc/cooldown semantics for the same keystones
- Moved remaining controlled champion offensive-vs-defensive ordering policy out of engine into script/data ownership:
  - offensive-ultimate-before-defensive-ability-two decision is now resolved in Vladimir script logic
  - policy default now loads from `Characters/Vladimir.json` under `simulation.controlled_champion.defensive_ability_two`
- Added controlled champion basic-attack event pipeline and runtime integration:
  - controlled champion now runs recurring auto-attack start/windup/hit events with hitbox/projectile checks
  - controlled champion attack cadence uses shared runtime attack-speed multipliers and cast-lock/untargetable guards
  - controlled champion spell hits now also consume shared runtime ability-bonus effects
- Added explicit controlled-champion unmodeled-rune diagnostics:
  - loadout resolution now records rune selections that have neither deterministic stat effects nor modeled combat-time runtime effects
  - reports and JSON output now surface these unmodeled runes explicitly
- Improved controlled-champion comparison and strict-stage search behavior:
  - added `controlled_champion_fixed_loadout` mode for direct item/rune/shard A/B evaluations with dedicated report/trace outputs
  - added strict-stage heuristic ordering knobs (`strict_ranking_enable_heuristic_ordering`, rune/shard signal weights, exploration promotions)
  - added a zero-variance guard so strict-stage heuristic ordering does not fabricate signal when strict seed scores are flat
  - made strict-score tie resolution deterministic with objective-side tiebreaks plus stable build-key fallback
- Improved Vladimir Sanguine Pool modeling and trace observability:
  - pool damage now executes as per-tick area damage-over-time with range checks per tick (using canonical `damage_per_tick` + `tick_interval_seconds` + `range`)
  - area-hit trace events now include enemy-hit counts for pool/area casts, improving validation/debugging of in-range assumptions
- Updated timed-budget semantics to measure timed search simulation work instead of setup time:
  - runtime budget deadline is now armed lazily on first timed-phase simulation evaluation
  - `maximum_quality` coverage remains pre-budget and does not arm timed deadline
  - very short budgets no longer expire before opponent scenario setup can enter simulation scoring
- Closed high-impact search and reporting correctness gaps from PR review:
  - full-loadout `beam` and `greedy` now co-optimize loadout selection while expanding item candidates
  - adaptive/bleed strategy ordering is now deterministic before index-based seed math (fixed-seed reruns stay reproducible)
  - seed-stage partial candidates are now deterministically completed before strict full-ranking fallback under timeouts
  - persistent-cache candidate scores now re-resolve candidate loadouts for metrics and build-order diagnostics
  - build-order optimization now evaluates each top candidate with that candidate's own loadout bonus stats
  - `controlled_champion_step` now recomputes level-scaled simulation defaults after controlled-level override
  - opponent encounter parsing now rejects all-zero-weight scenario sets
- Expanded parallel search orchestration and reduced scoring-path contention:
  - ensemble seed orchestration now runs in parallel
  - portfolio strategy execution now runs in parallel
  - strategy-elite and adaptive strategy candidate generation now run in parallel
  - search-type runtime counters now use atomic per-type counters (removed hot global mutex path)
  - unique scored-candidate key tracking now uses a sharded concurrent set (removed hot global mutex path)
  - report/JSON diagnostics now include explicit parallelism fields (effective threads + parallel mode flags)
- Continued generic controlled-champion decoupling in shared runtime paths:
  - added `src/scripts/champions/controlled_champion.rs` as the engine-facing controlled-champion script facade
  - removed remaining legacy Vladimir-named compatibility aliases in shared modules (`compute_vlad_stats`, `simulate_vlad_combat`, `VladCombatSimulation`)
  - normalized orchestration locals in `src/scenario_runner.rs` away from `vlad_*` naming
  - removed legacy `simulation.vlad_*` tuning overrides from shared parser; those keys now fail fast
  - primary CLI modes are now `controlled_champion` and `controlled_champion_step` (with Vladimir aliases retained for compatibility)
  - removed Vladimir ability-name hardcoding from shared engine trace/event paths; labels now come from controlled champion ability identifiers
- Improved maximum-quality coverage semantics and diagnostics:
  - incomplete coverage no longer implies hard failure and now emits explicit degraded-mode warning text/flags in console/report/JSON diagnostics
- Prevented persistent cache fragmentation for default random-seed runs:
  - persistent full-score cache partitioning now uses deterministic configured seed ownership; runtime-random default seeds share a stable cache partition
- Hardened search/runtime correctness and schema fail-fast behavior:
  - cooldown effects expressed in seconds are no longer converted into ability haste during deterministic loadout stat parsing
  - invulnerable-seconds objective normalization now references scenario horizon instead of a fixed one-second baseline
  - candidate generation can now score partial builds during strategy branching (improves greedy/beam pruning quality), while strict final ranking remains full-candidate only
  - `maximum_quality` coverage stage no longer uses popcorn progress-window timeout checks, preserving coverage guarantees before timed search
  - Pareto/EHP/AP metric diagnostics now apply controlled champion stack overrides, matching objective simulation assumptions
  - `simulation.protoplasm_trigger_health_percent` is now honored when provided
  - when `controlled_champion.level` overrides simulation fallback level, Protoplasm level-scaled defaults are recomputed to the effective controlled level unless explicitly overridden
  - loadout parsing now fails fast on deprecated keys instead of silently ignoring them:
    - `loadout.runes_reforged.rune_ids`
    - `loadout.season2016_masteries`
  - enemy respawn delay now uses each enemy actor's own level in mixed-level scenarios
- Added buff-aware runtime stat resolution for cooldown metrics:
  - introduced shared runtime stat resolver (`src/scripts/runtime/stat_resolution.rs`) that starts from base metric data and applies runtime buff state before use
  - item cooldowns for modeled runtime effects now load from canonical item data and resolve through buff state:
    - Heartsteel cooldown from `Items/Heartsteel.json` (`effects_structured[id=colossal_consumption_empowered_hit_damage_and_permanent_bonus_health]`)
    - Luden's Echo cooldown from `Items/Ludens Echo.json` (`effects_structured[id=echo_consume_stacks_for_primary_and_secondary_magic_damage]`)
    - Guardian Angel / Zhonya's Hourglass / Protoplasm Harness cooldowns resolve through the same runtime stat resolver path
  - enemy champion script ability cooldown scheduling now resolves from base cooldown plus runtime ability haste instead of using raw cooldown values directly
- Removed baseline reference-build workflow from controlled champion scenario outputs:
  - removed baseline parsing/evaluation (`controlled_champion.baseline_items` is now rejected)
  - report headline and objective-breakdown sections are now optimized-build only
  - event trace output now contains a single optimized-build timeline (no baseline vs best split)
- Improved run artifact naming and trace JSON structure:
  - popcorn run directory key now uses explicit labels and avoids duplicated `60s` segments when window equals hard budget
  - fixed historical `minumum` typo in runtime-stop key naming
  - trace JSON now emits versioned structured events (`schema_version`, `event_encoding`, `events[]`) with parsed timestamp/type/details fields
- Expanded runtime stat resolution to scalar combat metrics:
  - added resolver query paths for incoming damage taken, healing amounts, movement speed, and outgoing bonus-ability damage
  - controlled champion damage intake and healing application now resolve through shared stat queries instead of direct raw multipliers
  - enemy movement speed derivation now resolves from base move speed + flat/% bonuses through shared stat queries
  - controlled champion and loadout runtime bonus-damage/regen outputs now resolve through shared stat queries
- Added random-by-default search seed policy with explicit deterministic override:
  - `search.seed: 0` now means runtime-random seed
  - CLI now supports `--seed <u64>` to force deterministic reproducibility
  - reports now include the effective seed used by the run
- Added maximum-quality pre-budget coverage stage for breadth guarantees:
  - coverage now locks each legal item/rune/shard asset at least once
  - per-asset top diverse candidates are injected into main search as additional seeds
  - timed search budgets now start after coverage stage completion in `maximum_quality`
  - reports now include coverage-stage elapsed time, assets covered, and seeded-candidate counts
- Removed opponent scenario combat proxy fields and uptime-window toggle:
  - deleted `opponents.uptime_windows_enabled` support
  - deleted per-actor `combat` proxy support (`ability_dps_*`, `burst_*`, `stun_*`, `uptime_*`)
  - enemy runtime now uses only auto-attacks plus champion scripts sourced from canonical champion data
  - parser now fails fast if deprecated actor `combat` or opponent uptime-window fields are present
- Prevented controlled-champion cross-contamination from Vladimir script logic:
  - Vladimir offensive/defensive ability logic now executes only when the controlled champion is Vladimir
  - non-Vladimir controlled champions no longer inherit Vladimir pool/cast behavior implicitly
- Reduced scenario simulation block to scenario-owned knobs and moved gameplay defaults to canonical owners:
  - Vladimir Sanguine Pool defaults now load from `Characters/Vladimir.json` (`abilities.basic_ability_2`)
  - Zhonya, Guardian Angel, and Protoplasm defaults now load from item data files
  - controlled champion stasis activation default now loads from `Simulation/data/champion_ai_profiles.json`
  - Protoplasm passive trigger threshold now loads from `Items/Protoplasm Harness.json` only
  - URF respawn tuning remains owned by `Game Mode/URF.json` and is now treated as scenario override-only
  - removed duplicated simulation constants from the default scenario file
- Added dedicated scenario catalog and scenario-name resolution:
  - moved default scenario into `Simulation/scenarios/vladimir_urf_teamfight.json`
  - `--scenario` now accepts either a direct file path or a catalog name resolved to `Simulation/scenarios/<name>.json`
- Replaced legacy scenario schema compatibility with strict canonical scenario shape:
  - removed legacy parsing aliases (`vladimir_*`, top-level `enemies`, `enemy_scenarios`, and top-level `enemy_loadout`) from scenario execution paths
  - required canonical structure:
    - `controlled_champion.{champion, loadout}`
    - `opponents.{shared_loadout, encounters[].{name, weight, actors[]}}`
  - actor placement now supports explicit `placement.position` and strict `placement.movement` parsing (`hold_position`, `maintain_combat_range`)
  - build-order enemy level scaling now keys raw bases by stable actor `id`, not champion name display keys
- Removed duplicated top-level champion slot mapping data:
  - default slot bindings are now derived from canonical champion ability fields (`abilities.<ability>.slot` / `default_keybinding`)
  - removed `ability_slot_bindings` from `Characters/Vladimir.json`
  - updated defaults loader to derive stable runtime ability identifiers from champion + ability names when explicit ability identifiers are not present
- Completed roster-wide champion data cleanup aligned to canonical ownership:
  - removed remaining `behavior` and `scripts` gameplay constants from `Characters/Vayne.json` and `Characters/Warwick.json`
  - migrated Vayne Silver Bolts periodic true-hit defaults and Warwick Eternal Hunger/Infinite Duress scaling to typed loaders that read canonical ability/passive effects
  - removed Yasuo from champion script dispatch and deleted the Yasuo champion script module from `Simulation/src/scripts/champions/`
- Tightened data ownership and removed misplaced defaults from global simulator defaults:
  - Item stack assumptions are scenario-owned (`simulation.item_stacks_at_level_20` with controlled/opponent override maps) and no longer stored in `Items/Heartsteel.json`
  - Protoplasm Harness lifeline cooldown now comes from canonical item effects data in `Items/Protoplasm Harness.json` `effects_structured[id=lifeline_gain_bonus_health_below_health_threshold].cooldown_seconds`
  - removed item-specific defaults from `Simulation/data/simulator_defaults.json`
- Normalized champion simulation script config shape:
  - replaced champion-specific `simulation.<champion>_script_defaults` keys with `scripts.<script_key>`
  - updated typed loaders and champion script modules to read from the generic `scripts` container
- Normalized URF mode simulation key naming:
  - `Game Mode/URF.json` now uses `respawn` instead of `simulation_defaults.respawn`

- Added typed defaults loader layer with domain ownership:
  - global simulator/search/engine defaults: `Simulation/data/simulator_defaults.json`
  - mode defaults (URF respawn tuning): `Game Mode/URF.json`
  - champion simulation defaults: `Characters/*.json`
  - loader and accessors: `Simulation/src/defaults.rs`
- Moved search quality profile presets out of code and into defaults data:
  - `fast`, `balanced`, and `maximum_quality` profile numbers now come from defaults file
- Split champion execution data ownership between champion data and AI controller policy:
  - per-ability execution geometry/routing overrides are now canonical under `Characters/*.json` `abilities.<ability_key>.execution`
  - controller policy (combat spacing, movement scaling, script polling, and non-canonical cooldown overrides) now loads from `Simulation/data/champion_ai_profiles.json`
  - removed script schedule constants from champion files and switched script casting to cooldown-ready polling (`cast when ready`)
- Completed ability-execution schema migration from behavior/scripts to canonical ability data:
  - removed generic ability/burst execution keys from `behavior` in champion data and defaults
  - reworked `Characters/ChampionDefaults.json` into champion-style nested schema (`base_stats`, `basic_attack`, `abilities.execution_defaults`) and removed explicit zero-value entries
  - moved champion-specific execution settings to `abilities.<ability_key>.execution`
  - updated engine and champion scripts to consume ability execution profiles from ability data with defaults fallback
- Removed duplicated Morgana script timing field and promoted canonical ability ownership:
  - `scripts.dark_binding_and_soul_shackles.soul_shackles_detonate_delay_seconds` was removed from `Characters/Morgana.json`
  - Soul Shackles detonation delay now loads from `abilities.ultimate.effects[id=tether_duration]` in `Simulation/src/defaults.rs`
- Moved Morgana script followup priority policy to AI ownership:
  - removed `scripts.dark_binding_and_soul_shackles.soul_shackles_detonate_priority` from `Characters/Morgana.json`
  - added `script_priority_overrides.soul_shackles_detonate` under `Simulation/data/champion_ai_profiles.json` for Morgana
- Added runtime ability-slot mapping foundation for slot-agnostic casting:
  - introduced `ActorAbilityLoadout` with runtime slot-to-ability mapping in `src/scripts/runtime/ability_slots.rs`
  - controlled champion cooldown tracking now keys by ability identity rather than fixed slot cooldown fields
- Added hitbox-aware impact and interruption simulation in core combat loop:
  - actor hitboxes are modeled as circles and included in range checks
  - attack/spell/script effects now use configurable effect-hitbox radii
  - projectile barrier checks now include projectile and barrier thickness
  - impact outcomes are explicit (`applied`, `projectile_blocked`, `impact_nullified`, `*_missed`)
  - melee auto-attacks cancel when attacker is stunned during windup
- Improved report readability and diagnostics detail:
  - added human-readable timestamps (local + UTC)
  - added comma-separated large-number formatting for major diagnostics values
  - removed unix timestamp output from generated reports
  - added explicit generated/duplicate-pruned/unique candidate counts
  - added strict-stage completion percentage and timeout-skipped/non-finite candidate counts
- Standardized champion script layout to a uniform per-champion folder structure:
  - `src/scripts/champions/<champion>/mod.rs`
  - shared dispatch and types in `src/scripts/champions/mod.rs`
- Removed role-coupled champion script API naming:
  - renamed `EnemyScript*` types to `ChampionScript*`
  - renamed script execution fields from enemy/controlled-champion coupling to actor/target semantics
  - renamed `enemy_index` target snapshots to `target_index`
- Extracted defensive item and revive decisions into generic runtime/item script capabilities:
  - moved stasis/revive/emergency-shield trigger logic out of Vladimir-specific decision types
  - added role-neutral defensive decision APIs in `src/scripts/runtime/controlled_champion_loadout.rs`
  - moved defensive item availability detection into `src/scripts/items/hooks.rs`
  - engine now consumes generic item/runtime capability APIs
- Added run output partitioning by run type and runtime budget:
  - outputs now default under `Simulation/output/runs/controlled_champion/<search_quality_profile>/<runtime_budget>/`
  - keeps short and long-budget runs separated (for example `unbounded`, `300s`).
- Added controlled champion orchestration/report abstraction updates:
  - scenario execution/report writing APIs now use controlled champion naming
  - report headers and loadout sections now use the selected controlled champion name
  - default report and trace file names are now champion-keyed instead of hardcoded to Vladimir
- Added configurable URF respawn game-time scaling:
  - respawn delay now supports post-threshold time scaling with per-minute growth and cap
  - added simulation knobs:
    - `urf_respawn_time_scaling_enabled`
    - `urf_respawn_time_scaling_start_seconds`
    - `urf_respawn_time_scaling_per_minute_seconds`
    - `urf_respawn_time_scaling_cap_seconds`
- Enforced runtime budget checks across all major phases and search loops.
- Added phase-aware periodic status updates from initialization through finalization.
- Moved enemy URF presets into a data file:
  - `Simulation/data/enemy_urf_presets.json`
  - Includes source links and last checked date.
- Added strict startup validation for enemy preset items, runes, and shards.
- Added structured run output JSON:
  - default path mirrors markdown report with `.json` extension.
- Added search quality profiles:
  - `fast`
  - `balanced`
  - `maximum_quality`
- Replaced full permutation build order search with beam plus optimistic bound pruning.
- Build-order optimization now uses composite stage objective accumulation:
  - time alive
  - damage dealt
  - healing done
  - per-stage objective components are emitted in reports/JSON output.
- Added regression tests for legality and key rules.
- Added persistent full-score cache across runs under:
  - `Simulation/output/cache/`
- Added first-pass module split for simulation extensions:
  - `src/respawn.rs`
  - `src/scripts/champions/vladimir/mod.rs`
- Added additional modular extraction for orchestration support:
  - `src/cache.rs`
  - `src/status.rs`
- Added additional module split for maintainability:
  - `src/core.rs`
  - `src/build_order.rs`
  - `src/reporting.rs`
  - `src/search.rs`
  - `src/scenario_runner.rs`
  - `src/engine.rs`
  - `src/data.rs`
- Added enemy lifecycle simulation:
  - enemies can die from Vladimir damage
  - enemies respawn using URF-scaled death timer logic
- Added first-pass scripted Vladimir offensive cadence:
  - `Q`, `E`, and `R` damage/heal behavior integrated into the event loop
- Added strict final ranking parallel batches using Rayon for faster full candidate scoring.
- Added cap-survivor handling in output and tie-break:
  - cap-survivor labeling in reports/output
  - tie-break uses existing objective damage/healing weights
- Added first-pass script hook framework for non-generic mechanics:
  - `src/scripts/hooks.rs` dispatches item/champion/loadout hooks
  - `src/scripts/item_hooks.rs` now owns Heartsteel stack assumptions
  - `src/scripts/champions/vladimir/mod.rs` now owns Crimson Pact stat conversion logic
  - `src/scripts/loadout_hooks.rs` now annotates dynamic rune effects
- Added controlled-champion loadout runtime integration across simulation and objective scoring:
  - new generic engine API (`ControlledChampionCombatSimulation`, `simulate_controlled_champion_combat`)
  - transitional compatibility wrappers for legacy Vladimir names were retained at that stage (later removed)
  - combat-time loadout runtime effects now apply on controlled champion spell hits, kill events, and regeneration ticks
  - objective evaluation now threads loadout selection into combat simulation for candidate loadout scoring
- Removed remaining legacy hook and enemy-script interface hardcoding:
  - `LoadoutHookContext` now uses only `for_controlled_champion`
  - enemy script execution input now uses controlled champion naming for position, range, and health fields
  - engine event and helper names now prefer controlled champion terminology across shared combat flow
- Added generic champion end-stat helper and migrated internal use:
  - `compute_champion_final_stats` is now the primary helper
  - transitional compatibility wrapper for `compute_vlad_stats` was retained at that stage (later removed)
- Migrated script architecture from flat files to domain-oriented hierarchy:
  - champions:
    - `src/scripts/champions/mod.rs`
    - `src/scripts/champions/vladimir/mod.rs`
    - `src/scripts/champions/warwick/mod.rs`
    - `src/scripts/champions/vayne/mod.rs`
    - `src/scripts/champions/morgana/mod.rs`
    - `src/scripts/champions/sona/mod.rs`
    - `src/scripts/champions/doctor_mundo/mod.rs`
  - items:
    - `src/scripts/items/hooks.rs`
  - runes:
    - `src/scripts/runes/effects.rs`
  - runtime:
    - `src/scripts/runtime/controlled_champion_loadout.rs`
    - `src/scripts/runtime/loadout_runtime.rs`
  - registry:
    - `src/scripts/registry/hooks.rs`
- Removed obsolete root-level script files after migration:
  - `src/scripts/enemies.rs`
  - `src/scripts/hooks.rs`
  - `src/scripts/item_hooks.rs`
  - `src/scripts/loadout_hooks.rs`
  - `src/scripts/loadout_runtime.rs`
  - `src/scripts/vladimir.rs`
- Added first-pass 2D action timeline realism:
  - enemies are placed in 2D range bands around Vladimir and remain stationary
  - auto-attacks use start/windup/hit phases
  - ranged attacks and enemy spells use projectile travel time
  - Vladimir `Q`/`E`/`R` now use cast windup timing (and travel where configured)
- Added first-pass enemy champion behavior script profiles:
  - Warwick
  - Vayne
  - Morgana
  - Sona
  - Doctor Mundo
- Added repository automation workflows:
  - pull request and main branch continuous integration in `.github/workflows/continuous-integration.yml`
  - tag-based release generation with findings in `.github/workflows/release.yml`
- Enforced strict lint gating:
  - all current code passes `cargo clippy --all-targets --all-features -- -D warnings`
  - CI now hard-fails on any new Clippy warning.
- Added enemy derived-combat diagnostics and similarity warnings:
  - report/JSON output now includes per-enemy HP/AD/AS/range/hit/burst derived stats
  - warns when enemy auto-attack profiles look suspiciously similar
- Improved death/respawn state realism:
  - transient stack counters clear on enemy death and respawn
  - enemies respawn at their original spawn position
- Improved scripted event lifecycle correctness:
  - scripted champion events are epoch-gated across death/respawn transitions
  - stale queued script events are invalidated instead of leaking across lifecycle transitions
- Fixed projectile-blocking segment intersection edge cases:
  - colinear-but-disjoint projectile paths no longer register as blocked
- Extracted Vladimir combat decision logic into script-owned APIs:
  - offensive cast scheduling delegated to `src/scripts/champions/vladimir/mod.rs`
  - Vladimir defensive ability (pool) decision delegated to `src/scripts/champions/vladimir/mod.rs`
  - defensive item/revive decisions delegated to `src/scripts/runtime/controlled_champion_loadout.rs`
- Extracted enemy champion-specific script event behavior into scripts dispatch:
  - `src/scripts/champions/mod.rs` now owns champion event action generation
  - `src/engine.rs` now applies generic script actions
- Added foundational generic combat primitives scaffold:
  - status effects model (`kind`, `duration`, `stacks`, `persistence`)
  - cast-lock model (`windup`, `channel`, `lockout`)
  - deterministic per-tick updates wired into simulation time advancement

## Not Done
- [P0] Slot-agnostic ability architecture (keybind decoupling and ability remapping)
  - Goal: support runtime ability swapping/remapping without hardcoding abilities to fixed champion keybind slots.
  - Scope:
    - separate cast slot/input binding from ability identity and script behavior.
    - represent per-actor slot maps in data/runtime state (not champion-specific struct fields).
    - support ability theft/copy patterns (for example stolen ultimates) through generic runtime ownership/context.
    - keep champion-specific exceptions in ability scripts/data, not in core engine branches.
  - Success criteria:
    - the same ability script can be attached to different actors and different keybind slots at runtime.
    - no shared engine conditionals are needed for champion-specific stolen-ability routing.

- [P1] Add a second controlled champion script end-to-end (non-Vladimir)
  - Goal: validate that the controlled-champion architecture is truly multi-champion in production paths.
  - Scope:
    - add one non-Vladimir controlled champion script implementation with canonical data loaders.
    - add/update one scenario that runs `--mode controlled_champion` using the new champion.
    - keep engine/shared modules unchanged except for generic extension points.
  - Success criteria:
    - controlled-champion scenario runs successfully for at least one non-Vladimir champion.
    - no champion-specific hardcoding is added to shared core modules.

- [P1] Optional strict maximum-quality coverage gate
  - Goal: support reproducibility/CI runs that require complete pre-budget coverage.
  - Scope:
    - add an explicit opt-in flag (for example `--require-full-coverage`) that fails the run when coverage is incomplete.
    - preserve current default behavior: degraded mode with warning and output flag.
    - document the semantics in CLI/docs/report diagnostics.
  - Success criteria:
    - default runs keep warning-mode behavior.
    - strict mode deterministically fails with actionable diagnostics when coverage is incomplete.

- [P1] Data-driven controlled champion script registry
  - Goal: remove static registry coupling in `src/scripts/champions/controlled_champion.rs`.
  - Scope:
    - introduce a cleaner registration pattern for controlled champion script capabilities.
    - keep interface role-neutral and preserve current script resolution semantics.
    - ensure new champions can be added with minimal registry boilerplate.
  - Success criteria:
    - adding a new controlled champion script is a small, localized change.
    - no engine changes required for registry growth.

- [P1] Controlled champion non-Vladimir integration guardrail
  - Goal: prevent regressions where generic mode silently drifts back to Vladimir-only assumptions.
  - Scope:
    - add an integration test that runs `--mode controlled_champion` with a non-Vladimir scenario.
    - assert stable run/report contract behavior for that scenario.
    - keep assertions deterministic and CI-friendly.
  - Success criteria:
    - CI includes at least one passing non-Vladimir controlled-champion integration path.
    - regressions in generic controlled-champion orchestration are caught early.

- [P1] Controlled champion defensive ability risk-gate policy (discussion needed)
  - Goal: avoid unconditional defensive-ability spam while preserving intended “pool in multi-enemy windows” behavior.
  - Scope:
    - design a reusable risk gate for defensive ability two (for example low-health threshold and/or imminent-burst/projectile window).
    - keep defensive ability damage identity in scripts, but gate activation based on risk-aware policy.
    - ensure offensive weaving opportunities (for example ultimate priority) remain possible when risk is low.
  - Success criteria:
    - defensive ability casts are no longer purely cooldown-driven.
    - behavior remains deterministic and data/script-driven.

- [P1] Objective invulnerability contribution guardrail cap/curve (discussion needed)
  - Goal: prevent objective exploitation from excessive invulnerable/untargetable uptime under future tuning drift.
  - Scope:
    - evaluate soft cap and/or diminishing-return curve for invulnerability objective contribution.
    - preserve invulnerability as a meaningful metric without allowing it to dominate mixed objectives.
    - document selected approach and rationale in simulator docs/report diagnostics.
  - Success criteria:
    - invulnerability contribution cannot overwhelm objective ranking.
    - scoring remains interpretable and stable across search profiles.

- [P2] Vertical `z` dimension modeling decision
  - Goal: explicitly track and validate whether vertical `z` index impacts gameplay outcomes in simulator scope.
  - Current policy:
    - ignore `z` for combat checks and use 2D geometry only.
  - Follow-up:
    - revisit only when a verified gameplay interaction requires `z` in calculations.

- [P0] Full codebase structure audit and abstraction-first reorganization
  - Goal: examine the entire simulator codebase layout and optimize it for long-term versatility.
  - Scope:
    - review all modules for abstraction boundaries and ownership clarity.
    - identify files that should move, split, or be grouped by domain.
    - define phased migration checkpoints so functionality remains stable while restructuring.
  - Success criteria:
    - documented target architecture with an ordered migration checklist.
    - reduced cross-module coupling and cleaner extension points.

- [P1] File naming and module-size standards for maintainability
  - Goal: enforce consistent, descriptive naming and avoid oversized files.
  - Scope:
    - define naming standards for files, folders, modules, and registries.
    - apply progressive splits to large files into focused submodules where practical.
    - preserve language idioms while favoring descriptive names.
  - Success criteria:
    - new and migrated modules follow documented naming conventions.
    - large modules are split into smaller units with clear responsibilities.

- [P1] Architecture revisit checkpoints after each major feature tranche
  - Goal: continually reassess structure as functionality expands.
  - Scope:
    - add explicit post-tranche architecture review tasks.
    - track and close structural follow-up items before they accumulate.
  - Success criteria:
    - architecture debt remains bounded and visible.
    - structural improvements land continuously instead of as rare large rewrites.

- [P0] Full-fidelity Vladimir kit simulation (`Q`, `E`, `R`, passives)
  - Goal: upgrade first-pass scripted abilities to closer in-game behavior fidelity.
  - Scope:
    - Add full spell-state nuances, empowered states, and target-selection details.
    - Model cast times/windups and expected hit geometry with position model.
    - Preserve deterministic tick/event behavior.
  - Success criteria:
    - Offensive outcomes track expected ability scaling and timing behavior more closely.
    - Unit tests cover ability cooldown and cast ordering invariants.

- [P1] Composite objective refinement and guardrails
  - Goal: improve build quality under mixed metrics while avoiding pathological results.
  - Scope:
    - Add survivability floor gating for obviously non-viable builds.
    - Add optional diminishing returns/soft caps for damage and healing components.
    - Emit per-scenario component breakdown in reports.
  - Success criteria:
    - Top builds satisfy survivability floor.
    - Reports clearly explain why a build scored highly.

- [P2] Expand script hooks to full mechanic coverage
  - Goal: extend hook coverage for all non-generic item/champion/rune behavior.
  - Scope:
    - Add script implementations for additional stack items and champion passives.
    - Add hook-driven combat-time rune behavior (not only notes).
    - Keep hooks deterministic and compatible with search parallelism.
  - Success criteria:
    - Multiple complex mechanics implemented entirely through hooks.
    - No regression to strict candidate search stability.

- [P2] Robustness and stability sweeps
  - Goal: distinguish stable winners from seed/weight-sensitive outliers.
  - Scope:
    - Run multi-seed and multi-weight preset sweeps.
    - Summarize robust versus fragile builds in report output.
  - Success criteria:
    - Report explicitly identifies high-confidence stable loadouts.
    - Repeat runs show reduced variance in recommended top builds.

- [P1] Scenario preflight validator command
  - Goal: fail fast on bad scenario/preset input before expensive search begins.
  - Scope:
    - add a `--mode validate_scenario` (or equivalent) command path.
    - validate scenario schema, rune-page legality, shard-slot legality, and opponent preset availability.
    - return actionable error messages with exact failing path/field.
  - Success criteria:
    - invalid scenarios/presets fail in seconds with clear messages.
    - valid scenarios pass without running search.

- [P1] Score cache versioning and invalidation policy
  - Goal: prevent stale full-score cache reuse after schema/engine/scoring changes.
  - Scope:
    - add cache version stamp components (engine version, scoring config version, scenario schema version) to cache keys or cache metadata.
    - invalidate or bypass incompatible cache entries automatically.
  - Success criteria:
    - no cross-version cache contamination after scoring/model changes.
    - cache hit behavior is deterministic and auditable.

- [P1] Explicit rune-page structure input model
  - Goal: remove ambiguity from rune-page input by representing selection structurally.
  - Scope:
    - add optional structured fields for primary path, secondary path, and per-slot rune picks.
    - derive ordered `rune_names` from structural input in one canonical path.
    - preserve strict legality checks and deterministic serialization.
  - Success criteria:
    - scenario/preset authors cannot accidentally provide ambiguous rune ordering.
    - generated and parsed rune pages round-trip without information loss.

- [P1] Legal rune-page domain table/export
  - Goal: make the constrained rune-page search space explicit and auditable.
  - Scope:
    - enumerate all legal rune pages from `RunesReforged.json` constraints.
    - emit a deterministic table/report with:
      - total legal pages
      - grouped counts by primary path and secondary path pair
      - optional shard-combination expansion counts
    - provide a command/output artifact so results can be regenerated after data updates.
  - Success criteria:
    - total legal rune-page domain size is visible and reproducible.
    - changes in rune data produce clear before/after domain diffs.

- [P1] Ability-driven opponent scripts to replace DPS proxy fields
  - Goal: increase realism by modeling opponent combat timelines through scripted abilities/events.
  - Priority:
    - highest immediate realism impact among remaining simulator upgrades.
  - Scope:
    - migrate high-impact opponents from flat `ability_dps_*` proxies to ability/event casts.
    - keep shared engine role-neutral while champion-specific behavior stays in scripts/data.
    - maintain deterministic tick/event outcomes.
  - Success criteria:
    - reduced reliance on proxy DPS fields in primary scenarios.
    - opponent output timelines are ability/state driven.

- [P2] Combat-time rune coverage expansion plan
  - Goal: broaden dynamic rune behavior coverage in runtime scripts.
  - Scope:
    - prioritize high-impact runes appearing in top builds and opponent presets.
    - add script behavior tests for trigger timing, cooldown, and stacking semantics.
  - Success criteria:
    - runtime rune coverage materially increases for commonly selected pages.
    - report skipped-dynamic-rune notes decrease for top results.

- [P2] Opponent preset refresh workflow and staleness checks
  - Goal: keep `enemy_urf_presets.json` maintainable and easy to refresh when desired.
  - Scope:
    - add a small utility/workflow to review and update preset metadata (`source_url`, `last_checked`).
    - add optional warning/report line when preset age exceeds a configured threshold.
  - Success criteria:
    - preset refresh process is scripted and repeatable.
    - stale preset metadata is visible in run output.


- [P0] Action timeline realism follow-up (blocking, collision, movement)
  - Goal: complete fidelity work beyond current 2D+windup+travel model.
  - Scope:
    - Add projectile-blocking interactions where applicable.
    - Add collision/pathing-aware projectile resolution.
    - Add explicit movement updates for champions (currently stationary).
  - Success criteria:
    - Projectile-block interactions are represented in combat outcomes.
    - Position changes and movement materially affect hit timing and uptime.

- [P1] Enemy ability simulation depth for champion scripts
  - Goal: deepen champion kit fidelity beyond first-pass behavior profiles.
  - Scope:
    - Expand per-champion scripts beyond profile-level timing and on-hit effects.
    - Add ability-state interactions and per-champion sequencing nuances.
    - Keep scripts outside the core engine loop and data-driven where possible.
  - Success criteria:
    - Enemy champions show distinct, kit-driven combat timelines.
    - Script modules are testable independently from the core simulation engine.

- [P1] Preset/build correctness audit (enemy autos and itemization variance)
  - Goal: explain and fix cases where enemy champions appear to use overly similar auto-attack behavior/build outcomes.
  - Scope:
    - Audit enemy preset ingestion and per-champion stat application.
    - Verify item/rune effects are applied distinctly per champion.
    - Add validation/report checks to flag suspiciously similar enemy profiles.
  - Success criteria:
    - Per-enemy derived combat stats are printed in diagnostics.
    - Champion-to-champion auto attack profiles materially differ where expected.

- [P1] Codebase modularization and script-friendly architecture
  - Goal: eliminate single-file bottleneck and keep champion/item logic out of `main.rs`.
  - Scope:
    - Split core into modules (engine, search, reporting, data loading, scripts, CLI).
    - Move item/champion/rune special cases into dedicated script modules/hooks.
    - Define clear interfaces for extending champion/item behavior.
  - Success criteria:
    - `main.rs` becomes a thin CLI orchestration entrypoint.
    - New champion/item behavior can be added without touching core engine files.

- [P1] CI/CD for pull requests, main branch, and releases
  - Goal: automate quality checks and release artifacts with run findings.
  - Scope:
    - Add CI workflows for pull requests and main:
      - build
      - test
      - formatting/lint gates
    - Add release workflow that packages binary and attaches generated findings/report summary.
  - Success criteria:
    - PRs and main branch enforce green checks.
    - Releases include artifacts plus generated run report in release notes/attachments.

- [P2] Repository quality gates (linting, style, module boundaries)
  - Goal: enforce maintainable structure and coding standards automatically.
  - Scope:
    - Add `rustfmt` and `clippy` checks in CI.
    - Add deny/warn policy for common maintainability issues.
    - Add lightweight module size/ownership conventions in docs.
  - Success criteria:
    - New changes consistently conform to style and lint rules.
    - Core simulation logic stays split across coherent modules over time.

## Open Questions
- Enemy respawn behavior:
  - Implement using URF death timer scaling by level (not a fixed `20.0s`).
  - Decision:
    - Use documented SR level scaling through level 18, then extrapolate smoothly for levels 19-30 with conservative clamping.
    - Apply URF modifier (minus 3 seconds) on top of the scaled timer.
    - Keep the respawn timer model configurable so we can swap in a verified full table later.
    - cooldown timers continue while dead.
    - buffs/debuffs that do not persist through death are removed.
    - persist-through-death effects remain.
- Position model scope:
  - Decision:
    - Start with 1D range bands and deterministic spacing assumptions.
    - Expand to 2D coordinates in a follow-up after projectile travel/blocking is stable.
- Cap-survivor ranking:
  - Decision:
    - Use combined `damage dealt + healing done` tie-break metric.
    - Reuse existing objective weights (no separate custom weighting logic).

## Research Notes (2026-02-15)
- URF death timer patch history:
  - `V13.1b` entry explicitly states: "Death timers reduced by 3 seconds at all levels."
  - No newer URF patch-history entry found that explicitly reverts this.
  - Sources:
    - https://www.leagueoflegends.com/en-us/news/game-updates/patch-13-1b-notes/
    - https://wiki.leagueoflegends.com/en-us/Ultra_Rapid_Fire/Patch_and_Buff_History
- Baseline death timer model (SR reference):
  - Base Respawn Wait by level (1-18): `10, 10, 12, 12, 14, 16, 20, 25, 28, 32.5, 35, 37.5, 40, 42.5, 45, 47.5, 50, 52.5` seconds.
  - Time Increase Factor applies by game time after 15 minutes (with cap).
  - Sources:
    - https://wiki.leagueoflegends.com/en-us/Death
    - https://leagueoflegends.fandom.com/wiki/Death
- Death-state effects:
  - Documented behavior indicates many buffs/debuffs are removed on death unless marked to persist through death.
  - Cooldown behavior should be treated as continuing through death unless contradicted by targeted in-client validation.
  - Sources:
    - https://wiki.leagueoflegends.com/en-us/Death
    - https://leagueoflegends.fandom.com/wiki/Death
