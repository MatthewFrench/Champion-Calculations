#!/usr/bin/env python3
"""Generate simulation coverage trackers from repository data and modeled runtime constants."""

from __future__ import annotations

import json
import re
from pathlib import Path
from typing import Iterable

REPO_ROOT = Path(__file__).resolve().parents[2]
SIMULATION_DIR = REPO_ROOT / "Simulation"


def normalize_key(value: str) -> str:
    return "".join(ch for ch in value.lower() if ch.isalnum())


def read_json(path: Path):
    with path.open("r", encoding="utf-8") as handle:
        return json.load(handle)


def parse_rust_const_array(path: Path, const_name: str) -> list[str]:
    text = path.read_text(encoding="utf-8")
    pattern = re.compile(
        rf"{re.escape(const_name)}\s*:\s*&\[&str\]\s*=\s*&\[(.*?)\];",
        re.DOTALL,
    )
    match = pattern.search(text)
    if not match:
        raise RuntimeError(f"Could not locate {const_name} in {path}")
    block = match.group(1)
    return re.findall(r'"([^"]+)"', block)


def load_champion_names() -> list[str]:
    names: list[str] = []
    for path in sorted((REPO_ROOT / "Characters").glob("*.json")):
        if path.stem == "ChampionDefaults":
            continue
        champion = read_json(path)
        name = champion.get("name") or path.stem
        names.append(str(name))
    return sorted(names)


def load_item_names_with_nontrivial_effects() -> list[str]:
    names: list[str] = []
    for path in sorted((REPO_ROOT / "Items").glob("*.json")):
        item = read_json(path)
        passives = item.get("passives") or []
        active = item.get("active")
        structured = item.get("effects_structured") or []
        has_active = bool(active) and active != {"description": ""}
        if passives or has_active or structured:
            names.append(str(item.get("name") or path.stem))
    return sorted(set(names))


def load_rune_names() -> list[str]:
    runes_reforged = read_json(REPO_ROOT / "Masteries" / "RunesReforged.json")
    names: set[str] = set()
    for path in runes_reforged.get("paths", []):
        for slot in path.get("slots", []):
            for rune in slot.get("runes", []):
                rune_name = rune.get("name")
                if rune_name:
                    names.add(rune_name)
    return sorted(names)


def checklist_lines(names: Iterable[str], modeled_keys: set[str]) -> list[str]:
    lines: list[str] = []
    for name in names:
        checked = normalize_key(name) in modeled_keys
        lines.append(f"- [{'x' if checked else ' '}] {name}")
    return lines


def write_champion_tracker(modeled_controlled: set[str], modeled_enemy: set[str], champions: list[str]) -> None:
    controlled_count = sum(1 for name in champions if normalize_key(name) in modeled_controlled)
    enemy_count = sum(1 for name in champions if normalize_key(name) in modeled_enemy)
    content = [
        "# Champion Roster Validation Tracker",
        "",
        "Generated by `Simulation/scripts/generate_coverage_trackers.py`.",
        "",
        "## Champion Baseline Validation Checklist",
        "- [x] Canonical data file exists under `Characters/`",
        "- [x] Included in `load_champion_bases()` parsing pass",
        "- [x] Covered by `simulation_smoke_runs_for_all_champion_bases` unit test",
        "",
        f"## Controlled Champion Script Coverage ({controlled_count}/{len(champions)})",
        "- [x] indicates modeled controlled champion script capability is available.",
        *checklist_lines(champions, modeled_controlled),
        "",
        f"## Enemy Scripted Event Coverage ({enemy_count}/{len(champions)})",
        "- [x] indicates modeled enemy scripted-event capability is available.",
        *checklist_lines(champions, modeled_enemy),
        "",
    ]
    (SIMULATION_DIR / "CHAMPION_ROSTER_TRACKER.md").write_text("\n".join(content), encoding="utf-8")


def write_execution_tracker(
    champions: list[str],
    controlled_modeled: set[str],
    enemy_modeled: set[str],
    item_names: list[str],
    modeled_item_keys: set[str],
    rune_names: list[str],
    modeled_rune_keys: set[str],
) -> None:
    controlled_count = sum(1 for name in champions if normalize_key(name) in controlled_modeled)
    enemy_count = sum(1 for name in champions if normalize_key(name) in enemy_modeled)
    modeled_items = sum(1 for name in item_names if normalize_key(name) in modeled_item_keys)
    modeled_runes = sum(1 for name in rune_names if normalize_key(name) in modeled_rune_keys)

    content = [
        "# Coverage Execution Tracker",
        "",
        "Generated by `Simulation/scripts/generate_coverage_trackers.py`.",
        "",
        "This tracker is execution-oriented and derived from current runtime modeling constants and canonical data.",
        "",
        "## Champion Execution",
        "- [x] Baseline canonical champion data imported from `Characters/`",
        "- [x] Simulation smoke test executes loaded champion bases",
        f"- [ ] Controlled champion script capability for each roster champion ({controlled_count}/{len(champions)})",
        f"- [ ] Enemy scripted-event depth parity for each roster champion ({enemy_count}/{len(champions)})",
        "",
        f"## Item Runtime Effect Coverage ({modeled_items}/{len(item_names)})",
        "- [x] indicates an item has modeled runtime effect support in `scripts::coverage::MODELED_RUNTIME_ITEM_EFFECT_KEYS`.",
        *checklist_lines(item_names, modeled_item_keys),
        "",
        f"## Rune Runtime Coverage ({modeled_runes}/{len(rune_names)})",
        "- [x] indicates a rune has modeled dynamic runtime support in `scripts::runes::effects::DYNAMIC_RUNE_KEYS`.",
        *checklist_lines(rune_names, modeled_rune_keys),
        "",
        "## Mastery Coverage",
        "- [ ] Legacy Season 2016 mastery runtime support is not implemented (policy currently disabled).",
        "",
    ]
    (SIMULATION_DIR / "COVERAGE_EXECUTION_TRACKER.md").write_text("\n".join(content), encoding="utf-8")


def main() -> None:
    coverage_rs = SIMULATION_DIR / "src" / "scripts" / "coverage.rs"
    rune_effects_rs = SIMULATION_DIR / "src" / "scripts" / "runes" / "effects.rs"

    modeled_item_keys = set(parse_rust_const_array(coverage_rs, "MODELED_RUNTIME_ITEM_EFFECT_KEYS"))
    modeled_controlled = set(
        parse_rust_const_array(coverage_rs, "MODELED_CONTROLLED_CHAMPION_SCRIPT_KEYS")
    )
    modeled_enemy = set(
        parse_rust_const_array(coverage_rs, "MODELED_ENEMY_SCRIPT_EVENT_CHAMPION_KEYS")
    )
    modeled_rune_keys = set(parse_rust_const_array(rune_effects_rs, "DYNAMIC_RUNE_KEYS"))

    champions = load_champion_names()
    item_names = load_item_names_with_nontrivial_effects()
    rune_names = load_rune_names()

    write_champion_tracker(modeled_controlled, modeled_enemy, champions)
    write_execution_tracker(
        champions,
        modeled_controlled,
        modeled_enemy,
        item_names,
        modeled_item_keys,
        rune_names,
        modeled_rune_keys,
    )


if __name__ == "__main__":
    main()
